// Website Vulnerability Scanner
// Analyzes websites for security issues: SSL, headers, XSS, SQLi patterns

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Security issue severity
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub enum Severity {
    Critical,
    High,
    Medium,
    Low,
    Info,
}

/// A detected security issue
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityIssue {
    pub severity: Severity,
    pub category: String,
    pub title: String,
    pub description: String,
    pub recommendation: String,
}

/// Security scan results
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanResult {
    pub url: String,
    pub scanned_at: i64,
    pub score: u8, // 0-100
    pub grade: String, // A+, A, B, C, D, F
    pub issues: Vec<SecurityIssue>,
    pub headers_present: Vec<String>,
    pub headers_missing: Vec<String>,
    pub ssl_info: Option<SslInfo>,
}

/// SSL/TLS information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SslInfo {
    pub valid: bool,
    pub issuer: String,
    pub expires: String,
    pub protocol: String,
    pub cipher: String,
}

/// Website vulnerability scanner
pub struct VulnerabilityScanner {
    // Known vulnerable patterns
    xss_patterns: Vec<&'static str>,
    sqli_patterns: Vec<&'static str>,
    required_headers: HashMap<&'static str, &'static str>,
}

impl VulnerabilityScanner {
    pub fn new() -> Self {
        let mut required_headers = HashMap::new();
        required_headers.insert("Strict-Transport-Security", "Enforces HTTPS connections");
        required_headers.insert("Content-Security-Policy", "Prevents XSS and injection attacks");
        required_headers.insert("X-Frame-Options", "Prevents clickjacking");
        required_headers.insert("X-Content-Type-Options", "Prevents MIME sniffing");
        required_headers.insert("X-XSS-Protection", "Legacy XSS protection");
        required_headers.insert("Referrer-Policy", "Controls referrer information");
        required_headers.insert("Permissions-Policy", "Controls browser features");
        
        Self {
            xss_patterns: vec![
                "<script", "javascript:", "onerror=", "onload=", "onclick=",
                "onmouseover=", "onfocus=", "onblur=", "eval(", "document.cookie",
                "document.write", "innerHTML=", "outerHTML=",
            ],
            sqli_patterns: vec![
                "' OR '1'='1", "'; DROP TABLE", "UNION SELECT", "' OR 1=1",
                "1=1--", "' OR ''='", "admin'--", "or 1=1#",
            ],
            required_headers,
        }
    }
    
    /// Analyze a page's HTML for vulnerabilities
    pub fn analyze_html(&self, html: &str, url: &str) -> Vec<SecurityIssue> {
        let mut issues = Vec::new();
        let html_lower = html.to_lowercase();
        
        // Check for inline scripts (potential XSS vectors)
        if html_lower.contains("<script>") || html_lower.contains("<script ") {
            let script_count = html_lower.matches("<script").count();
            if script_count > 5 {
                issues.push(SecurityIssue {
                    severity: Severity::Medium,
                    category: "JavaScript".to_string(),
                    title: "Multiple Inline Scripts".to_string(),
                    description: format!("Page contains {} inline scripts which may include malicious code", script_count),
                    recommendation: "Use external scripts with integrity checks (SRI)".to_string(),
                });
            }
        }
        
        // Check for dangerous patterns
        for pattern in &self.xss_patterns {
            if html_lower.contains(&pattern.to_lowercase()) {
                issues.push(SecurityIssue {
                    severity: Severity::High,
                    category: "XSS".to_string(),
                    title: "Potential XSS Vector".to_string(),
                    description: format!("Found potentially dangerous pattern: {}", pattern),
                    recommendation: "Ensure user input is properly sanitized".to_string(),
                });
                break; // Only report once
            }
        }
        
        // Check for password fields without HTTPS
        if html_lower.contains("type=\"password\"") || html_lower.contains("type='password'") {
            if !url.starts_with("https://") {
                issues.push(SecurityIssue {
                    severity: Severity::Critical,
                    category: "Authentication".to_string(),
                    title: "Password Field Over HTTP".to_string(),
                    description: "Password input field found on non-HTTPS page".to_string(),
                    recommendation: "Always use HTTPS for pages with sensitive forms".to_string(),
                });
            }
        }
        
        // Check for mixed content
        if url.starts_with("https://") {
            if html_lower.contains("src=\"http://") || html_lower.contains("src='http://") {
                issues.push(SecurityIssue {
                    severity: Severity::Medium,
                    category: "Mixed Content".to_string(),
                    title: "Mixed Content Detected".to_string(),
                    description: "HTTPS page loading resources over HTTP".to_string(),
                    recommendation: "Load all resources over HTTPS".to_string(),
                });
            }
        }
        
        // Check for outdated libraries (simple pattern matching)
        let outdated_libs = [
            ("jquery-1.", "jQuery 1.x (outdated)"),
            ("jquery-2.", "jQuery 2.x (outdated)"),
            ("angular.min.js", "AngularJS 1.x (outdated)"),
            ("bootstrap-3.", "Bootstrap 3.x (outdated)"),
        ];
        
        for (pattern, lib_name) in outdated_libs {
            if html_lower.contains(pattern) {
                issues.push(SecurityIssue {
                    severity: Severity::Medium,
                    category: "Outdated Library".to_string(),
                    title: format!("Outdated Library: {}", lib_name),
                    description: "Using an outdated JavaScript library with known vulnerabilities".to_string(),
                    recommendation: "Update to the latest version".to_string(),
                });
            }
        }
        
        // Check for eval usage
        if html_lower.contains("eval(") {
            issues.push(SecurityIssue {
                severity: Severity::High,
                category: "Dangerous Function".to_string(),
                title: "eval() Usage Detected".to_string(),
                description: "The eval() function can execute arbitrary code".to_string(),
                recommendation: "Avoid using eval() - use safer alternatives".to_string(),
            });
        }
        
        issues
    }
    
    /// Analyze security headers
    pub fn analyze_headers(&self, headers: &HashMap<String, String>) -> (Vec<String>, Vec<SecurityIssue>) {
        let mut present = Vec::new();
        let mut issues = Vec::new();
        
        for (header, description) in &self.required_headers {
            let header_lower = header.to_lowercase();
            let found = headers.keys().any(|k| k.to_lowercase() == header_lower);
            
            if found {
                present.push(header.to_string());
            } else {
                issues.push(SecurityIssue {
                    severity: Severity::Medium,
                    category: "Missing Header".to_string(),
                    title: format!("Missing: {}", header),
                    description: format!("Security header not present: {}", description),
                    recommendation: format!("Add {} header to responses", header),
                });
            }
        }
        
        // Check for dangerous headers
        if headers.contains_key("Server") {
            let server = headers.get("Server").unwrap();
            if server.contains('/') {
                issues.push(SecurityIssue {
                    severity: Severity::Low,
                    category: "Information Disclosure".to_string(),
                    title: "Server Version Exposed".to_string(),
                    description: format!("Server header reveals: {}", server),
                    recommendation: "Hide server version information".to_string(),
                });
            }
        }
        
        (present, issues)
    }
    
    /// Calculate security score
    pub fn calculate_score(&self, issues: &[SecurityIssue]) -> (u8, String) {
        let mut score: i32 = 100;
        
        for issue in issues {
            match issue.severity {
                Severity::Critical => score -= 25,
                Severity::High => score -= 15,
                Severity::Medium => score -= 10,
                Severity::Low => score -= 5,
                Severity::Info => score -= 1,
            }
        }
        
        let score = score.max(0) as u8;
        let grade = match score {
            90..=100 => "A+",
            80..=89 => "A",
            70..=79 => "B",
            60..=69 => "C",
            50..=59 => "D",
            _ => "F",
        };
        
        (score, grade.to_string())
    }
    
    /// Generate JavaScript to inject for client-side scanning
    pub fn get_injection_script() -> String {
        r#"
// Website Security Scanner
(function() {
    'use strict';
    
    const securityIssues = [];
    
    // Check for insecure forms
    document.querySelectorAll('form').forEach(form => {
        const action = form.action || '';
        if (action.startsWith('http://')) {
            securityIssues.push({
                type: 'INSECURE_FORM',
                message: 'Form submits data over HTTP'
            });
        }
    });
    
    // Check for external scripts without integrity
    document.querySelectorAll('script[src]').forEach(script => {
        const src = script.src || '';
        if (src.startsWith('http') && !script.integrity) {
            securityIssues.push({
                type: 'NO_SRI',
                message: 'External script without integrity check: ' + src.substring(0, 50)
            });
        }
    });
    
    // Check for localStorage usage (privacy concern)
    const originalSetItem = localStorage.setItem;
    localStorage.setItem = function(key, value) {
        console.log('%c[ServionX] Site storing data: ' + key, 'color: #f59e0b;');
        return originalSetItem.apply(this, arguments);
    };
    
    // Report issues
    if (securityIssues.length > 0) {
        console.log('%c[ServionX] Security scan found ' + securityIssues.length + ' issues:', 'color: #ef4444;');
        securityIssues.forEach(issue => {
            console.log('  - ' + issue.type + ': ' + issue.message);
        });
    } else {
        console.log('%c[ServionX] Security scan: No major issues detected', 'color: #22c55e;');
    }
})();
"#.to_string()
    }
}

impl Default for VulnerabilityScanner {
    fn default() -> Self {
        Self::new()
    }
}

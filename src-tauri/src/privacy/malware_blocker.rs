// Malware and Phishing URL Blocklist
// Blocks known malicious domains and URLs

use std::collections::HashSet;
use std::sync::RwLock;

/// Known malicious patterns and domains
const MALWARE_DOMAINS: &[&str] = &[
    // Phishing patterns (examples - real blocklist would be much larger)
    "appleid-verify.com",
    "paypal-secure-login.com",
    "amazon-account-verify.com",
    "netflix-billing.com",
    "google-account-verify.com",
    "microsoft-verify.com",
    "bank-secure-login.com",
    "facebook-security.com",
    "instagram-verify.com",
    "twitter-secure.com",
    
    // Known malware domains
    "malware-test.com",
    "virus-download.com",
    "trojan-installer.com",
    "ransomware-payload.com",
    "cryptominer-script.com",
    "keylogger-download.com",
    "spyware-install.com",
    "adware-bundle.com",
    
    // Suspicious TLDs often used for malware
    // Note: These would be checked as patterns, not exact matches
];

/// Suspicious URL patterns
const SUSPICIOUS_PATTERNS: &[&str] = &[
    // Phishing indicators
    "login-verify",
    "account-suspended",
    "security-alert",
    "password-reset-urgent",
    "confirm-identity",
    "verify-account",
    "billing-update",
    "payment-failed",
    "account-locked",
    "unusual-activity",
    
    // Malware indicators
    "free-download",
    "crack-software",
    "keygen",
    "warez",
    "nulled",
    
    // Cryptocurrency scams
    "crypto-giveaway",
    "btc-double",
    "eth-airdrop",
    "free-bitcoin",
];

/// Malware and phishing blocker
pub struct MalwareBlocker {
    blocked_domains: RwLock<HashSet<String>>,
    suspicious_patterns: Vec<String>,
    enabled: RwLock<bool>,
    blocked_count: RwLock<u64>,
    warnings_count: RwLock<u64>,
}

impl MalwareBlocker {
    pub fn new() -> Self {
        let mut domains = HashSet::new();
        for domain in MALWARE_DOMAINS {
            domains.insert(domain.to_string());
        }
        
        let patterns: Vec<String> = SUSPICIOUS_PATTERNS.iter()
            .map(|s| s.to_string())
            .collect();
        
        Self {
            blocked_domains: RwLock::new(domains),
            suspicious_patterns: patterns,
            enabled: RwLock::new(true),
            blocked_count: RwLock::new(0),
            warnings_count: RwLock::new(0),
        }
    }
    
    /// Check if a URL is malicious
    pub fn check_url(&self, url: &str) -> MalwareCheckResult {
        if !*self.enabled.read().unwrap() {
            return MalwareCheckResult::Safe;
        }
        
        let url_lower = url.to_lowercase();
        
        // Check against blocked domains
        if let Some(domain) = extract_domain(&url_lower) {
            let domains = self.blocked_domains.read().unwrap();
            for blocked in domains.iter() {
                if domain == *blocked || domain.ends_with(&format!(".{}", blocked)) {
                    *self.blocked_count.write().unwrap() += 1;
                    log::warn!("Blocked malicious URL: {}", url);
                    return MalwareCheckResult::Blocked {
                        reason: format!("Known malicious domain: {}", blocked),
                    };
                }
            }
        }
        
        // Check suspicious patterns
        for pattern in &self.suspicious_patterns {
            if url_lower.contains(pattern) {
                *self.warnings_count.write().unwrap() += 1;
                log::warn!("Suspicious URL pattern detected: {} in {}", pattern, url);
                return MalwareCheckResult::Suspicious {
                    reason: format!("Suspicious pattern detected: {}", pattern),
                };
            }
        }
        
        // Check for homograph attacks (IDN spoofing)
        if contains_homograph_chars(url) {
            *self.warnings_count.write().unwrap() += 1;
            return MalwareCheckResult::Suspicious {
                reason: "Possible homograph attack (lookalike domain)".to_string(),
            };
        }
        
        MalwareCheckResult::Safe
    }
    
    /// Add a domain to the blocklist
    pub fn add_blocked_domain(&self, domain: &str) {
        self.blocked_domains.write().unwrap().insert(domain.to_lowercase());
    }
    
    /// Get statistics
    pub fn get_blocked_count(&self) -> u64 {
        *self.blocked_count.read().unwrap()
    }
    
    pub fn get_warnings_count(&self) -> u64 {
        *self.warnings_count.read().unwrap()
    }
    
    /// Enable/disable the blocker
    pub fn set_enabled(&self, enabled: bool) {
        *self.enabled.write().unwrap() = enabled;
    }
}

impl Default for MalwareBlocker {
    fn default() -> Self {
        Self::new()
    }
}

/// Result of malware check
#[derive(Debug, Clone)]
pub enum MalwareCheckResult {
    Safe,
    Suspicious { reason: String },
    Blocked { reason: String },
}

/// Extract domain from URL
fn extract_domain(url: &str) -> Option<String> {
    let url = url.trim_start_matches("https://")
        .trim_start_matches("http://");
    let domain = url.split('/').next()?;
    let domain = domain.split(':').next()?;
    Some(domain.to_lowercase())
}

/// Check for homograph attack characters
fn contains_homograph_chars(url: &str) -> bool {
    // Common lookalike characters used in phishing
    let suspicious_chars = ['а', 'е', 'о', 'с', 'р', 'і', 'ј']; // Cyrillic lookalikes
    
    for c in url.chars() {
        if suspicious_chars.contains(&c) {
            return true;
        }
    }
    false
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_malware_detection() {
        let blocker = MalwareBlocker::new();
        
        // Test blocked domain
        match blocker.check_url("https://appleid-verify.com/login") {
            MalwareCheckResult::Blocked { .. } => (),
            _ => panic!("Should be blocked"),
        }
        
        // Test safe URL
        match blocker.check_url("https://apple.com/account") {
            MalwareCheckResult::Safe => (),
            _ => panic!("Should be safe"),
        }
        
        // Test suspicious pattern
        match blocker.check_url("https://example.com/free-download/software") {
            MalwareCheckResult::Suspicious { .. } => (),
            _ => panic!("Should be suspicious"),
        }
    }
}
